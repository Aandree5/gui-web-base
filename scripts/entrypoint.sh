#!/bin/sh
# Copyright 2025 Andr√© Silva
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


set -eu

# Default umask
UMASK="${UMASK:-${GWB_UMASK:-077}}"
umask "$UMASK"
echo "Using umask: $UMASK"

# Target PUID and PGID
PUID=${PUID:-${GWB_UID:-1000}}
PGID=${PGID:-${GWB_GID:-1000}}

# Current gwb UID and GID
CURRENT_UID=$(id -u gwb || echo -1)
CURRENT_GID=$(id -g gwb || echo -1)

# $APP_DIRS - Directories to fix permissions for downstream image
# All directories to fix permissions
PERMISSIONS_DIRS="$GWB_HOME $XDG_RUNTIME_DIR ${APP_DIRS:-}"

echo "Current UID:GID = ${CURRENT_UID:-<missing>}:${CURRENT_GID:-<missing>}"
echo "Target UID:GID = $PUID:$PGID"

TARGET_USER="gwb"
TARGET_GROUP="gwb"

fix_dirs_permissions() {
    for d in $PERMISSIONS_DIRS; do
        if [ -e "$d" ]; then
            dir_uid=$(stat -c '%u' "$d")
            dir_gid=$(stat -c '%g' "$d")
            
            if [ "$dir_uid" != "$PUID" ] || [ "$dir_gid" != "$PGID" ]; then
                echo "Fixing ownership for $d (was $dir_uid:$dir_gid, needs $PUID:$PGID)"
                if ! chown -R "$PUID:$PGID" "$d"; then
                    echo "ERROR: failed to set ownership on $d to $PUID:$PGID" >&2
                    exit 1
                fi
            fi
        else
            echo "Creating $d owned by $PUID:$PGID"
            mkdir -p "$d"
            chown "$PUID:$PGID" "$d"
            chmod 700 "$d"
        fi
    done
}

# Update permissions only if current UID or GID differ from target
if [ "$CURRENT_UID" != "$PUID" ] || [ "$CURRENT_GID" != "$PGID" ]; then
    # Ensure group exists for PGID (create if missing)
    if getent group "$PGID" >/dev/null 2>&1; then
        TARGET_GROUP=$(getent group "$PGID" | cut -d: -f1)
        echo "Using existing group $TARGET_GROUP (GID $PGID)"
    else
        # If gwb exists, modify it, otherwise create new user
        if [ "$CURRENT_GID" -ge 0 ]; then
            echo "Modifying existing group gwb to GID:$PGID"
            groupmod -g "$PGID" "gwb"
        else
            echo "Creating group $TARGET_GROUP with GID $PGID"
            groupadd -g "$PGID" "$TARGET_GROUP"
        fi
    fi
    
    # Ensure a user exists with the target PUID
    if getent passwd "$PUID" >/dev/null 2>&1; then
        TARGET_USER=$(getent passwd "$PUID" | cut -d: -f1)
        echo "Found existing user $TARGET_USER with UID $PUID"
    else
        # If gwb exists, modify it, otherwise create new user
        if [ "$CURRENT_UID" -ge 0 ]; then
            echo "Modifying existing user gwb to UID:$PUID GID:$PGID"
            usermod -u "$PUID" -g "$PGID" "gwb"
        else
            echo "Creating user gwb with UID:$PUID GID:$PGID"
            useradd -m -u "$PUID" -g "$PGID" -d "$GWB_HOME" -s /bin/sh gwb
        fi
    fi
    
    # Fix ownership of directories
    fix_dirs_permissions
else
    TARGET_USER=$(getent passwd "$PUID" | cut -d: -f1)
    
    # Check PERMISSIONS_DIRS even if UID/GID are unchanged
    # Make sure ownership is correct
    fix_dirs_permissions
fi

export SSL_CERT_PATH="${CERT_PATH:-/etc/xpra/ssl/ssl-cert.pem}"
EXPIRY_THRESHOLD=$((30 * 24 * 60 * 60))  # 30 days in seconds

generate_new_ssl_certificate() {
    openssl genrsa -out server.key 2048
    openssl req -new -key server.key -out server.csr -subj "/CN=localhost/OU=gui-web-base" -addext "subjectAltName = DNS:localhost,IP:127.0.0.1"
    openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
    
    cat server.key server.crt > "$SSL_CERT_PATH"
    rm -f server.key server.crt server.csr
    
    chown "$PUID:$PGID" "$SSL_CERT_PATH"
    chmod 600 "$SSL_CERT_PATH"
}

if [ ! -f "$SSL_CERT_PATH" ]; then
    echo "Generating self-signed SSL certificate..."
    generate_new_ssl_certificate
else
    if openssl x509 -checkend "$EXPIRY_THRESHOLD" -noout -in "$SSL_CERT_PATH"; then
        echo "SSL certificate is valid for more than 30 days."
    else
        EXPIRY_DATE=$(openssl x509 -enddate -noout -in "$SSL_CERT_PATH" | cut -d= -f2)
        
        echo "SSL certificate is expiring on: $EXPIRY_DATE"
        if openssl x509 -in "$SSL_CERT_PATH" -noout -subject | grep -q "OU=gui-web-base"; then
            echo "Certificate was generated by Gui web base, regenerating..."
            generate_new_ssl_certificate
        else
            echo "[WARNING] External certificate detected, skipping regeneration."
        fi
    fi
fi

echo "Executing as $TARGET_USER"
exec dumb-init -- gosu "$TARGET_USER" "$@"
